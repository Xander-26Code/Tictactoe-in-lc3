# LC3 井字棋 (TicTacToe) 代码逻辑详解

本文档详细解析了 [tictactoe.asm](file:///Users/xander/Library/Mobile%20Documents/com~apple~CloudDocs/2390project/tictactoe.asm) 汇编代码的各个模块逻辑及其协同工作原理。

## 1. 整体架构与主循环 (Main Loop)

程序的入口是 `START` 标签。整个游戏通过一个无限循环 `GAME_LOOP` 来驱动，直到游戏结束（胜利或平局）。

### 流程图解
1.  **初始化 (`INIT_BOARD`)**: 将棋盘清空。
2.  **设置玩家**: 默认玩家 1 (X) 先手。
3.  **循环开始 (`GAME_LOOP`)**:
    *   **显示棋盘 (`PRINT_BOARD`)**: 打印当前的 3x3 网格。
    *   **获取移动 (`GET_MOVE`)**: 询问当前玩家落子位置，并验证输入合法性。
    *   **更新棋盘 (`UPDATE_BOARD`)**: 将玩家的棋子 (X 或 O) 存入内存。
    *   **检查胜利 (`CHECK_WIN`)**: 判断当前玩家是否连成三子。如果是，跳转到胜利处理。
    *   **检查平局 (`CHECK_DRAW`)**: 判断棋盘是否已满。如果是，跳转到平局处理。
    *   **切换玩家**: 如果是 X 则换 O，是 O 则换 X。
    *   **回到循环开始**。

---

## 2. 模块详解 (Subroutines)

### 2.1 初始化棋盘 (`INIT_BOARD`)
*   **功能**: 将内存中预留的 9 个棋盘位置全部填充为 ASCII 空格 (`x0020`)。
*   **逻辑**:
    *   使用寄存器 `R2` 作为计数器，初始值为 9。
    *   使用 `R0` 指向 `BOARD` 的首地址。
    *   在一个循环中，将空格字符 (`R1`) 存入 `R0` 指向的地址，然后 `R0` 加 1，`R2` 减 1。
    *   当 `R2` 减到 0 时，初始化完成。

### 2.2 打印棋盘 (`PRINT_BOARD`)
*   **功能**: 在控制台绘制可视化的井字棋网格。
*   **逻辑**:
    *   这是一个嵌套结构。外层逻辑负责打印 3 行，内层逻辑负责打印每一行中的 3 个格子。
    *   **打印单元格**: 它不是打印固定的 "X" 或 "O"，而是从 `BOARD` 内存中读取当前位置的字符（可能是空格、X 或 O）并输出。
    *   **格式化**: 使用 `V_BAR` (" | ") 分隔列，使用 `H_DIV` ("--+---+--") 分隔行。
    *   通过 `R1` 追踪当前要打印的 `BOARD` 内存地址，每打印一个格子 `R1` 加 1。

### 2.3 获取并验证输入 (`GET_MOVE`)
*   **功能**: 读取用户输入的数字 (1-9)，并确保它是合法的移动。
*   **逻辑**:
    *   **提示**: 打印 "Player X: " 提示符。
    *   **读取**: 使用 `GETC` 读取一个字符。
    *   **范围验证**:
        *   将输入字符减去 '1' 的 ASCII 值。如果结果小于 0，说明输入小于 '1'，非法。
        *   将结果再减去 9。如果结果大于等于 0，说明输入大于 '9'，非法。
    *   **空位验证**:
        *   计算对应的 `BOARD` 内存地址。
        *   读取该位置的值，判断是否等于空格。如果不等于空格（即已经是 X 或 O），则提示 "Spot taken" 并要求重输。
    *   **返回值**: 如果合法，`R0` 返回 0-8 的索引值（输入 '1' 对应索引 0）。

### 2.4 更新棋盘 (`UPDATE_BOARD`)
*   **功能**: 将当前玩家的标记写入棋盘内存。
*   **逻辑**:
    *   接收 `R0` 中的索引 (0-8)。
    *   计算目标地址：`BOARD` 基地址 + `R0` 偏移量。
    *   将 `CUR_PLAYER` (当前玩家字符) 存储 (`STR`) 到该地址。

### 2.5 检查胜利 (`CHECK_WIN`)
*   **功能**: 判断当前玩家是否获胜。
*   **逻辑**:
    *   **核心思想**: 并不需要复杂的算法，因为只有 8 种赢法（3行 + 3列 + 2对角线）。
    *   **数据驱动**: 定义了一个 `WINS` 数组，存储了所有赢法的索引组合（例如 0,1,2 代表第一行）。
    *   **遍历**:
        *   外层循环遍历 8 种组合。
        *   内层逻辑检查这 3 个位置的字符是否**都等于**当前玩家的字符。
    *   如果找到任意一种组合全匹配，返回 1 (胜利)；否则遍历结束返回 0。

### 2.6 检查平局 (`CHECK_DRAW`)
*   **功能**: 判断是否还有空位。
*   **逻辑**:
    *   遍历 `BOARD` 的 9 个位置。
    *   只要发现**任意一个**位置是空格，就说明没满，直接返回 0 (非平局)。
    *   如果循环结束都没发现空格，说明满了，返回 1 (平局)。

---

## 3. 数据结构 (Data Section)

*   `BOARD .BLKW 9`: 这是一个长度为 9 的数组，是游戏的核心数据结构。它在内存中连续存储，分别对应棋盘的左上、中上、右上...直到右下。
*   `CUR_PLAYER`: 存储当前是谁的回合 ('X' 或 'O')。
*   `WINS`: 一个查找表，存储了所有胜利连线的索引。这使得 `CHECK_WIN` 的代码可以写得很通用，不需要写 8 个 `IF` 语句。

## 4. 模块融合 (Integration)

这些模块通过 `JSR` (Jump to Subroutine) 指令在 `GAME_LOOP` 中串联起来。
*   **数据流**: `GET_MOVE` 产生的索引 (R0) 直接传递给 `UPDATE_BOARD` 使用。
*   **状态流**: `CUR_PLAYER` 变量在 `GAME_LOOP` 末尾被修改，从而影响下一次循环中 `PRINT_BOARD` (提示谁的回合) 和 `UPDATE_BOARD` (落什么子) 的行为。
*   **控制流**: `CHECK_WIN` 和 `CHECK_DRAW` 的返回值决定了是继续循环还是跳转到 `GAME_OVER` 标签。

这种模块化设计使得每个子程序只关注自己的任务（例如 `PRINT_BOARD` 只管打印，不关心谁赢了），代码清晰且易于调试。
